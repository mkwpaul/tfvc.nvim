local M = {}
local u = require('tfvc.utils')
local s = require('tfvc.state')

---@class tf_diff_opts
---@field versionspec version_spec? Which Versionspec to use. See :h tfvc.version_spec
---@field buf_id number? Which Buffer to use.
---@field force_fresh boolean? If true, the buffer will be reloaded from the server
---@field no_split boolean? If true, it will diff the file, but hide the file-split with which the local file is diff'd against
---@field open_folds boolean? If true, the folds autogenerated by the diffsplit command will be opened

--- field callback fun(new_buf : number)? optional callback

---@param opts tf_diff_opts
function M.tf_compare__(opts)

  local versionspec = opts.versionspec
  local buf_id = opts.buf_id

  if opts.no_split == nil then opts.no_split = s.user_vars.diff_no_split  end
  if opts.open_folds == nil then opts.open_folds = s.user_vars.diff_open_folds end

  local path = u.get_current_file('tf_compare', buf_id)
  if not path then
    return
  end
  buf_id = buf_id or vim.api.nvim_get_current_buf()
  versionspec = versionspec or s.user_vars.default_versionspec

  u.tf_get_version_from_versionspec(path, versionspec, opts.force_fresh, function(temp_file_path)
    -- the bang (! flag) turns off diff-mode for all windows in the current context
    vim.cmd.diffoff({ bang = true })
    vim.cmd.diffsplit(temp_file_path)

    -- diffsplit sets the newly loaded file as the current buffer
    local new_buf = vim.api.nvim_get_current_buf()
    vim.api.nvim_set_option_value('modifiable', false, { buf = new_buf })

    vim.b[new_buf].tf_versionspec = versionspec
    vim.b[new_buf].tf_isServerFile = true

    if opts.no_split then vim.cmd ':norm q' end
    if opts.open_folds then vim.cmd ':norm zr' end
  end)
end

-- experimental, directly use diffsplit with custom buftype uri
function M.tf_compare(opts)

  local versionspec = opts.versionspec
  local buf_id = opts.buf_id

  if opts.no_split == nil then opts.no_split = s.user_vars.diff_no_split  end
  if opts.open_folds == nil then opts.open_folds = s.user_vars.diff_open_folds end

  local path = u.get_current_file('tf_compare', buf_id)
  if not path then
    return
  end

  versionspec = versionspec or s.user_vars.default_versionspec

  -- the bang (! flag) turns off diff-mode for all windows in the current context
  vim.cmd.diffoff({ bang = true })
  vim.cmd.diffsplit('tfvc:///files/'..versionspec..'/'..path)

  -- diffsplit sets the newly loaded file as the current buffer
  local new_buf = vim.api.nvim_get_current_buf()
  -- vim.api.nvim_set_option_value('modifiable', false, { buf = new_buf })

  vim.b[new_buf].tf_versionspec = versionspec
  vim.b[new_buf].tf_isServerFile = true

  if opts.no_split then vim.cmd ':norm q' end
  if opts.open_folds then vim.cmd ':norm zr' end
end

function M.toggle_diff()
  local isDiff = vim.api.nvim_win_get_option(0, 'diff')
  if isDiff then
    vim.cmd(':diffo!')
    for _, value in pairs(vim.api.nvim_tabpage_list_wins(0)) do
      local buf_in_win = vim.api.nvim_win_get_buf(value)
      if vim.b[buf_in_win].tf_isServerFile then
        vim.api.nvim_win_close(value, true)
      end
    end
  else
    M.tf_compare({})
  end
end

---@param files string[] list of file paths
---@param version_spec version_spec
function M.preload_versions_for_files(files, version_spec, force_fresh)
  -- either get existing bufferId for create a new buffer for all files
  -- vim.print(vim.inspect(files))

  for _, file in pairs(files) do
    u.tf_get_version_from_versionspec(file, version_spec, force_fresh, function(temp)
      if s.user_vars.debug then
        print('Preloaded Version ' .. version_spec ..  '  for ' .. file .. ': ' .. temp)
      end
    end)
  end
end

local function cmd_from_verb(verb, pass_path, print_stdout, callback)

  ---@param opts vim.api.keyset.create_user_command.command_args
  return function(opts)
    local args = {}
    local path = nil
    if pass_path then
      path = #opts.fargs > 0 and opts.fargs[1] or u.get_current_file(verb)
      args = { 'vc' , verb, path }
    else
      args = { 'vc', verb }
    end
    u.tf_cmd(args, { print_stdout = print_stdout } , callback)
  end
end

-- TODO: add path completion for commands that take path as (optional) argument
-- TODO: support directory buffers (like netrw or oil) for commands that operate on files and directories

-- function path_completion(arg_lead, cmdline, cursorpos)
--   vim.fs.dir
-- end

---@type table<string,subcommand>
M.commands = {
  add = {
    desc = 'Add current File to Source Control',
    default_mapping = 'a',
    run = cmd_from_verb('add', true, false)
  },
  undo = {
    desc = 'Undo Pending Changes',
    default_mapping = 'u',
    run = cmd_from_verb('undo', true, false, function ()
      -- reload file after undoing changes
      vim.schedule(function () vim.cmd 'edit!' end)
    end),
  },
  delete = {
    desc = 'Delete file',
    run = cmd_from_verb('delete', true, true)
  },
  info = {
    desc = 'Show Info about file',
    default_mapping = 'i',
    run = cmd_from_verb('info', true, true)
  },
  checkout = {
    desc = 'Checkout file',
    default_mapping = 'c',
    run = cmd_from_verb('checkout', true, false, function ()
      vim.schedule(function() vim.cmd 'set noreadonly' end)
    end)
  },
  diff = {
    desc = 'Compare local file to Server Version',
    default_mapping = 'l',
    run = function (opts)
      local args = opts.fargs or {}
      local spec = nil
      if #args > 0 then
        spec = args[1]
      end
      local no_split = nil
      local fresh = opts.bang
      if fresh then no_split = false end

      M.tf_compare({
        versionspec = spec,
        force_fresh = fresh,
        no_split = no_split,
      })
    end
  },
  openWebHistory = {
    desc = 'Open Web History for current File/Directory',
    default_mapping = 'w',
    run = function() require('tfvc.history').cmd_open_web_history() end,
  },
  status = {
    desc = 'Status',
    default_mapping = 's',
    run = function(opts) require('tfvc.status').cmd_status(opts) end,
  },
  loadDiffs = {
    desc = 'Preload Diffs for changed files', default_mapping = 'pd',
    run = function (opts)
      local force_fresh = opts.bang
      local status = require('tfvc.status')
      local version_spec = u.get_versionspec_from_user()
      status.do_with_pending_changes(force_fresh, function(pending_changes)
        vim.schedule(function()
          local local_paths = vim.tbl_map(function(pending_change)
            return pending_change.Local end,
            pending_changes)
          M.preload_versions_for_files(local_paths, version_spec)
        end)
      end)
    end
  },
  clearCache = {
    desc = 'Clear any caches for server file versions and current local changes',
    run = function()
      local state = require('tfvc.state')
      state.file_versions = {}
      state.pending_changes = nil
    end
  },
  rename = {
    desc = 'Renames / moves file',
    default_mapping = 'r',
    complete = 'file',
    run = function (opts)
      local path = #opts.fargs > 0 and opts.fargs[1] or u.get_current_file('rename')
      if not path then return end
      local new_path = vim.fn.input({
        prompt = 'Enter new Filename: ',
        default = path,
        cancelreturn = nil,
      })
      if not new_path or new_path == '' then return end
      local cmd = { 'rename', path, new_path}
      u.tf_cmd(cmd, nil, function (obj)
        if obj.code == 0 then
          vim.schedule(function()
            vim.cmd.edit(new_path)
          end)
        end
      end)
    end,
  },
  history = {
    desc = 'Shows history of current file',
    default_mapping = 'h',
    complete = 'file',
    run = function (opts)
      local path = #opts.fargs > 0 and opts.fargs[1] or u.get_current_file('history') or '.'
      local opening_cmd = s.user_vars.history_open_cmd
      vim.cmd (opening_cmd .. ' tfvc:///history/'.. path)
    end
  }
}

local cmd_name = 'TF'

---@param opts vim.api.keyset.create_user_command.command_args
local function TF(opts)
  local fargs = opts.fargs
  local cmd = fargs[1]
  local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}
  local subcommand = M.commands[cmd]
  if subcommand then
    assert(type(subcommand.run) == 'function')
    opts.fargs = args
    subcommand.run(opts)
  else
    vim.notify(cmd_name .. ': Unknown subcommand: ' .. cmd, vim.log.levels.ERROR, { title = 'tfvc.nvim' })
  end
end

function M.set_default_keymaps()
  local leader =  '<leader>t'
  local dummyArgs = {
    fargs = {},
  }
  for _, mapping in pairs(M.commands) do
    if mapping.default_mapping then
      local motion = leader .. mapping.default_mapping
      vim.keymap.set('n', motion, function()
        mapping.run(dummyArgs)
      end,
        { desc = mapping.desc })
    end
  end
end

vim.api.nvim_create_user_command(cmd_name, TF, {
  nargs = '+',
  bang = true,
  range = true,
  desc = 'Interacts with TF Version Control',
  complete = function(arg_lead, cmdline, _)
    local all_commands = vim.tbl_keys(M.commands)

    local subcmd, subcmd_arg_lead = cmdline:match('^' .. cmd_name .. '[!]*%s(%S+)%s(.*)$')
    if subcmd and subcmd_arg_lead and M.commands[subcmd] and M.commands[subcmd].complete then
      --local complete = M.commands[subcmd].complete;
      return M.commands[subcmd].complete(subcmd_arg_lead)
    end

    if cmdline:match('^' .. cmd_name .. '[!]*%s+%w*$') then
      return vim.tbl_filter(function(command)
        return command:find(arg_lead) ~= nil
      end, all_commands)
    end
  end,
})

require 'tfvc.buftypes'

---@param opts tfvc_user_vars
function M.setup(opts)
  local tf = vim.g.tf or {}
  vim.g.tf = vim.tbl_deep_extend('force', tf, opts)
end

return M

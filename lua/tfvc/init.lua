local M = {}
local u = require('tfvc.utils')
local s = require('tfvc.state')

---@type tfvc_opts
M.default_opts = {
  create_default_mappings = false,
  tf_leader = '<leader>t',
  version_control_web_url = nil,
  workfold = nil,
  tf_path = nil,
  filter_status_by_cwd = true,

---@diagnostic disable-next-line: assign-type-mismatch
  project_url = nil,
}

---@type tfvc_opts
s = vim.tbl_extend('keep', s, M.default_opts, {})

---@class tf_diff_opts
---@field versionspec version_spec? Which Versionspec to use. See :h tfvc.version_spec
---@field buf_id number? Which Buffer to use.
---@field force_fresh boolean? If true, the buffer will be reloaded from the server
---@field no_split boolean? If true, it will diff the file, but hide the file-split with which the local file is diff'd against
---@field open_folds boolean? If true, the folds autogenerated by the diffsplit command will be opened

--- field callback fun(new_buf : number)? optional callback

---@param opts tf_diff_opts
function M.tf_compare(opts)

  local versionspec = opts.versionspec
  local buf_id = opts.buf_id

  if opts.no_split == nil then opts.no_split = vim.g.tf_no_split  end
  if opts.open_folds == nil then opts.open_folds = vim.g.tf_open_folds end

  local path = u.get_current_file('tf_compare', buf_id)
  if not path then
    return
  end
  buf_id = buf_id or vim.api.nvim_get_current_buf()
  versionspec = versionspec or s.default_version_spec or 'T'

  M.tf_get_version_from_versionspec(path, versionspec, opts.force_fresh, function(temp_file_path)
    -- the bang (! flag) turns off diff-mode for all windows in the current context
    vim.cmd.diffoff({ bang = true })
    vim.cmd.diffsplit(temp_file_path)

    -- diffsplit sets the newly loaded file as the current buffer
    local new_buf = vim.api.nvim_get_current_buf()
    vim.api.nvim_set_option_value('modifiable', false, { buf = new_buf })

    vim.b[new_buf].tf_versionspec = versionspec
    vim.b[new_buf].tf_isServerFile = true

    if opts.no_split then vim.cmd ':norm q' end
    if opts.open_folds then vim.cmd ':norm zr' end
  end)
end

function M.toggle_diff()
  local isDiff = vim.api.nvim_win_get_option(0, 'diff')
  if isDiff then
    vim.cmd(':diffo!')
    for key, value in pairs(vim.api.nvim_tabpage_list_wins(0)) do
      local buf_in_win = vim.api.nvim_win_get_buf(value)
      if vim.b[buf_in_win].tf_isServerFile then
        vim.api.nvim_win_close(value, true)
      end
    end
  else
    M.tf_compare({})
  end
end

---@param path string path to the file to get the version from
---@param versionspec version_spec 
---@param force_fresh boolean? If true, the buffer will be reloaded from the server
---@param callback fun(temp_file_path : string) continuation callback
function M.tf_get_version_from_versionspec(path, versionspec, force_fresh, callback)
  versionspec = versionspec or s.default_version_spec

  ---@type table<file_version>
  local cache = s.file_versions or {}
  if not force_fresh then
    local tmp_file = s.get_cached_file_version(versionspec, path)
    if tmp_file then
      callback(tmp_file)
      return
    end
  end

  local temp = vim.fn.tempname()
  local cmd = { 'vc', 'view', '/version:' .. versionspec, path, '/output:' .. temp }
  u.tf_cmd(cmd, false, function(obj)
    vim.schedule(function()
      if obj.code == 0 then
        if obj.stdout then
          print(obj.stdout)
        end
        ---@type file_version
        local cache_entry = {
          version_spec = versionspec,
          local_file = path,
          server_file = temp
        }

        -- remove existing cache entry if any
        for i, value in ipairs(cache) do
          if value.local_file == cache_entry.local_file then
            table.remove(cache, i)
            break
          end
        end
        table.insert(cache, cache_entry)
        callback(temp)
      end
    end)
  end)
end

---@param files string[] list of file paths
---@param version_spec version_spec
function M.preload_versions_for_files(files, version_spec, force_fresh)
  -- either get existing bufferId for create a new buffer for all files
  -- vim.print(vim.inspect(files))
  for _, file in pairs(files) do
    M.tf_get_version_from_versionspec(file, version_spec, force_fresh, function(temp)
      if s.debug then
        print('Preloaded Version ' .. version_spec ..  '  for ' .. file .. ': ' .. temp)
      end
    end)
  end
end

function M.get_versionspec_from_user()
  local prompt =
[[Versionspec:
    Date/Time         D"any .NET Framework-supported format"
                      or any of the date formats of the local machine
    Changeset number  Cnnnnnn
    Label             Llabelname
    Latest version    T
    Workspace         Wworkspacename;workspaceowner

VersionSpec > ]]

  local spec = vim.fn.input { prompt = prompt, default = '', cancelreturn = s.default_version_spec }
  return spec
end

local function cmd_from_verb(verb, pass_path, print_stdout, callback)

  ---@param opts vim.api.keyset.create_user_command.command_args
  return function(opts)
    local args = {}
    local path = nil
    if pass_path then
      path = #opts.fargs > 0 and opts.fargs[1] or u.get_current_file(verb)
      args = { 'vc' , verb, path }
    else
      args = { 'vc', verb }
    end
    u.tf_cmd(args, print_stdout, callback)
  end
end

-- TODO: add path completion for commands that take path as (optional) argument
-- TODO: support directory buffers (like netrw or oil) for commands that operate on files and directories

-- function path_completion(arg_lead, cmdline, cursorpos)
--   vim.fs.dir
-- end

---@type table<string,subcommand>
M.subcommand_tbl = {
  add = {
    desc = 'Add current File to Source Control',
    default_mapping = 'a',
    run = cmd_from_verb('add', true, false)
  },
  undo = {
    desc = 'Undo Pending Changes',
    default_mapping = 'u',
    run = cmd_from_verb('undo', true, false, function ()
      -- reload file after undoing changes
      vim.schedule(function () vim.cmd 'edit!' end)
    end),
  },
  delete = {
    desc = 'Delete file',
    run = cmd_from_verb('delete', true, true)
  },
  info = {
    desc = 'Show Info about file',
    default_mapping = 'i',
    run = cmd_from_verb('info', true, true)
  },
  checkout = {
    desc = 'Checkout file',
    default_mapping = 'c',
    run = cmd_from_verb('checkout', true, false, function ()
      vim.schedule(function() vim.cmd 'set noreadonly' end)
    end)
  },
  diff = {
    desc = 'Compare local file to Server Version',
    default_mapping = 'l',
    run = function (opts)
      local args = opts.fargs or {}
      local spec = s.default_version_spec or 'T'
      if #args > 0 then
        spec = args[1]
      end
      local no_split = nil
      local fresh = opts.bang
      if fresh then no_split = false end

      M.tf_compare({
        versionspec = spec,
        force_fresh = fresh,
        no_split = no_split,
      })
    end
  },
  -- history = {
  --   desc = 'List changesets for current buffer',
  --   default_mapping = 'h',
  --   run = function() require('tfvc.history').cmd_list_commits() end,
  -- },
  openWebHistory = {
    desc = 'Open Web History for current File/Directory',
    default_mapping = 'w',
    run = function() require('tfvc.history').cmd_open_web_history() end,
  },
  status = {
    desc = 'Status',
    default_mapping = 's',
    run = function(opts) require('tfvc.status').cmd_status(opts) end,
  },
  loadDiffs = {
    desc = 'Preload Diffs for changed files', default_mapping = 'pd',
    run = function (opts)
      local force_fresh = opts.bang
      local status = require('tfvc.status')
      local version_spec = M.get_versionspec_from_user()
      status.do_with_pending_changes(force_fresh, function(pending_changes)
        vim.schedule(function()
          local local_paths = vim.tbl_map(function(pending_change)
            return pending_change.Local end,
            pending_changes)
          M.preload_versions_for_files(local_paths, version_spec)
        end)
      end)
    end
  },
  clearCache = {
    desc = 'Clear any caches for server file versions and current local changes',
    run = function()
      local state = require('tfvc.state')
      state.file_versions = {}
      state.pending_changes = nil
    end
  },
  rename = {
    desc = 'Renames / moves file',
    default_mapping = 'r',
    complete = 'file',
    run = function (opts)
      local path = #opts.fargs > 0 and opts.fargs[1] or u.get_current_file('rename')
      if not path then return end
      local new_path = vim.fn.input({
        prompt = 'Enter new Filename: ',
        default = path,
        cancelreturn = nil,
      })
      if not new_path or new_path == '' then return end
      local cmd = { 'rename', path, new_path}
      u.tf_cmd(cmd, false, function (obj)
        if obj.code == 0 then
          vim.schedule(function()
            vim.cmd.edit(new_path)
          end)
        end
      end)
    end,
  },
}

local cmd_name = 'TF'

---@param opts vim.api.keyset.create_user_command.command_args
local function TF(opts)
  local fargs = opts.fargs
  local cmd = fargs[1]
  local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}
  local subcommand = M.subcommand_tbl[cmd]
  if subcommand then
    assert(type(subcommand.run) == 'function')
    opts.fargs = args
    subcommand.run(opts)
  else
    vim.notify(cmd_name .. ': Unknown subcommand: ' .. cmd, vim.log.levels.ERROR, { title = 'tfvc.nvim' })
  end
end

---@param opts tfvc_opts?
function M.setup(opts)
  local opts = vim.g.tf or {}
  opts = vim.tbl_extend('keep', opts, s)
  vim.g.tf = opts

  if s.debug then
    print(vim.inspect(opts))
  end

  if (opts.create_default_mappings) then
    local leader = opts.tf_leader
    local dummyArgs = {
      fargs = {},
    }
    for _, mapping in pairs(M.subcommand_tbl) do
      if mapping.default_mapping then
        local motion = leader .. mapping.default_mapping
        vim.keymap.set('n', motion, function()
          mapping.run(dummyArgs)
        end,
        { desc = mapping.desc })
      end
    end
  end

  vim.api.nvim_create_user_command(cmd_name, TF, {
    nargs = '+',
    bang = true,
    range = true,
    desc = 'Interacts with TF Version Control',
    complete = function(arg_lead, cmdline, _)
      local all_commands = vim.tbl_keys(M.subcommand_tbl)

      local subcmd, subcmd_arg_lead = cmdline:match('^' .. cmd_name .. '[!]*%s(%S+)%s(.*)$')
      if subcmd and subcmd_arg_lead and M.subcommand_tbl[subcmd] and M.subcommand_tbl[subcmd].complete then
        local complete = M.subcommand_tbl[subcmd].complete;
        return M.subcommand_tbl[subcmd].complete(subcmd_arg_lead)
      end

      if cmdline:match('^' .. cmd_name .. '[!]*%s+%w*$') then
        return vim.tbl_filter(function(command)
          return command:find(arg_lead) ~= nil
        end, all_commands)
      end
    end,
  })
end

return M
